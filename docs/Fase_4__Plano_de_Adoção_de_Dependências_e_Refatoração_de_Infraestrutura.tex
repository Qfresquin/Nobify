\documentclass[a4paper,12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{booktabs}

% Configuração de margens
\geometry{left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}

% Configuração de cores para código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{codeblue}{rgb}{0.1,0.1,0.8}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{codeblue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=single,
    language=C
}

\lstset{style=mystyle}

% Cabeçalho e Rodapé
\pagestyle{fancy}
\fancyhf{}
\rhead{\today}
\lhead{Refatoração: Bibliotecas Externas}
\rfoot{Página \thepage}

\title{\textbf{Plano de Refatoração de Infraestrutura}\\ \large Integração de Bibliotecas \textit{Single-Header}}
\author{Equipe de Desenvolvimento}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage

\chapter{Objetivo e Escopo}

O projeto atual implementa manualmente diversas funcionalidades de infraestrutura, como arrays dinâmicos, parsers matemáticos, execução de processos e manipulação de sistema de arquivos. Isso inflou o código do \texttt{transpiler\_evaluator} e do \texttt{build\_model}, aumentando a complexidade de manutenção e a superfície de bugs.

Este documento propõe a substituição dessas implementações manuais por bibliotecas C pequenas, portáveis e de arquivo único (\textit{single-header libraries}). Esta etapa é pré-requisito para a refatoração do \texttt{Dispatcher} e \texttt{Codegen}, pois simplificará drasticamente as dependências internas desses módulos.

\chapter{Stack Tecnológica Proposta}

Abaixo listamos as bibliotecas selecionadas para integração imediata. Todas são compatíveis com C99 e não requerem sistemas de build complexos (basta copiar o arquivo \texttt{.h}).

\begin{table}[h]
\centering
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Biblioteca} & \textbf{Domínio} & \textbf{Substitui no Projeto} & \textbf{Licença} \\ \midrule
\texttt{stb\_ds.h} & Estruturas de Dados & Listas encadeadas, Arrays manuais & Public Domain \\
\texttt{tinyexpr} & Matemática & Parser \texttt{math(EXPR ...)} customizado & zlib \\
\texttt{subprocess.h} & Processos & \texttt{CreateProcess} / \texttt{fork+exec} & Public Domain \\
\texttt{tinydir.h} & Filesystem & \texttt{glob} e leitura de diretórios & BSD \\
\texttt{tiny-regex-c} & Regex & Implementação manual de Regex & Public Domain \\ \bottomrule
\end{tabular}
\caption{Bibliotecas Recomendadas para Adoção}
\end{table}

\chapter{Plano de Integração por Módulo}

\section{1. Estruturas de Dados (stb\_ds.h)}
\textbf{Alvo:} \texttt{build\_model.c}, \texttt{logic\_model.c}

O modelo de dados atual sofre com buscas lineares ($O(N)$) e alocação manual de arrays. A \texttt{stb\_ds} oferece Hash Maps e Arrays Dinâmicos robustos.

\subsection{Mudanças Previstas}
\begin{itemize}
    \item \textbf{Hash Map de Targets:} Criar um mapa \texttt{string $\to$ int} para buscar índices de targets instantaneamente ($O(1)$).
    \item \textbf{Listas de Propriedades:} Substituir as listas manuais de \texttt{Conditional\_Property} por \texttt{arrput} (vetor dinâmico).
\end{itemize}

\begin{lstlisting}[caption={Exemplo: Substituindo busca linear por Hash Map}]
// ANTES (Busca Linear)
Build_Target* find_target(Model *m, char *name) {
    for (int i=0; i < m->count; ++i) {
        if (strcmp(m->targets[i].name, name) == 0) return &m->targets[i];
    }
    return NULL;
}

// DEPOIS (stb_ds)
#include "stb_ds.h"
struct { char *key; int value; } *target_map = NULL;

// Inserção
shput(target_map, target_name, target_index);

// Busca O(1)
int idx = shget(target_map, "MyTarget");
if (idx >= 0) return &m->targets[idx];
\end{lstlisting}

\section{2. Expressões Matemáticas (TinyExpr)}
\textbf{Alvo:} \texttt{transpiler\_evaluator.inc.c} (Futuro \texttt{math\_parser.c})

O parser de descida recursiva implementado atualmente no evaluator ocupa centenas de linhas e é difícil de manter.

\subsection{Mudanças Previstas}
\begin{itemize}
    \item Remover todas as funções \texttt{math\_parse\_*}.
    \item Substituir o comando \texttt{math(EXPR ...)} por uma chamada direta ao \texttt{te\_interp}.
\end{itemize}

\begin{lstlisting}[caption={Simplificação do Math Command}]
// math_parser.c
#include "tinyexpr.h"

bool eval_math_expression(const char *expr, double *result) {
    int error;
    *result = te_interp(expr, &error);
    return error == 0;
}
\end{lstlisting}

\section{3. Execução de Processos (subprocess.h)}
\textbf{Alvo:} \texttt{sys\_utils.c} (Extraído do evaluator)

A lógica atual tem muitos \texttt{\#ifdef \_WIN32} para lidar com \texttt{execute\_process} e probes de compilador.

\subsection{Mudanças Previstas}
\begin{itemize}
    \item Substituir chamadas de API nativa (Win32/POSIX) pela abstração unificada do \texttt{subprocess.h}.
    \item Simplificar a captura de \texttt{STDOUT} e \texttt{STDERR} para variáveis do CMake.
\end{itemize}

\section{4. Sistema de Arquivos (tinydir.h)}
\textbf{Alvo:} \texttt{sys\_utils.c}

Funções como \texttt{file(GLOB ...)} e \texttt{aux\_source\_directory} dependem de iteração de diretórios, que é não-portável em C padrão.

\subsection{Mudanças Previstas}
\begin{itemize}
    \item Implementar iteradores de diretório portáveis.
    \item Facilitar a implementação de \textit{globbing} recursivo (necessário para \texttt{GLOB\_RECURSE}).
\end{itemize}

\chapter{Impacto na Arena de Memória}

Uma consideração importante é como essas bibliotecas interagem com a \texttt{Arena} existente no projeto.

\begin{itemize}
    \item \textbf{Bibliotecas de I/O e Processos:} Não afetam a memória persistente. Usam memória temporária ou buffers fornecidos pelo usuário.
    \item \textbf{stb\_ds:} Usa \texttt{realloc} por padrão.
    \begin{itemize}
        \item \textit{Estratégia:} Para listas que crescem durante o parse e persistem até o final (ex: Targets), o uso do heap padrão (malloc/free) via \texttt{stb\_ds} é aceitável e simplifica o código.
        \item \textit{Alternativa:} É possível configurar \texttt{stb\_ds} para usar alocadores customizados, mas recomenda-se começar com o padrão para agilizar a refatoração.
    \end{itemize}
\end{itemize}

\chapter{Roteiro de Execução}

Para preparar o código para a análise do \texttt{Dispatcher} e \texttt{Codegen}, execute os passos:

\begin{enumerate}
    \item \textbf{Vendorização:} Criar pasta \texttt{src/vendor/} e baixar os headers (\texttt{stb\_ds.h}, \texttt{tinyexpr.h}, etc.).
    \item \textbf{Limpeza do Evaluator:}
        \begin{itemize}
            \item Remover código de parser matemático $\to$ Integrar \texttt{TinyExpr}.
            \item Remover código de \texttt{CreateProcess/fork} $\to$ Integrar \texttt{subprocess.h}.
        \end{itemize}
    \item \textbf{Refatoração do Model:}
        \begin{itemize}
            \item Introduzir \texttt{stb\_ds} para gerenciar a lista de Targets e Propriedades.
        \end{itemize}
    \item \textbf{Envio para Análise:} Após essa limpeza, o código estará pronto para enviarmos o \texttt{Dispatcher} e a \texttt{Arena} para revisão, focando puramente na arquitetura do transpiler e não em detalhes de implementação de baixo nível.
\end{enumerate}

\end{document}