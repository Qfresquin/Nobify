\documentclass[a4paper,12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{fancyhdr}

% Configuração de margens
\geometry{left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}

% Configuração de cores para código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{codeblue}{rgb}{0.1,0.1,0.8}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{codeblue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=single,
    language=C
}

\lstset{style=mystyle}

% Cabeçalho e Rodapé
\pagestyle{fancy}
\fancyhf{}
\rhead{\today}
\lhead{Auditoria: Build Model}
\rfoot{Página \thepage}

\title{\textbf{Relatório de Auditoria Técnica}\\ \large Análise de Estrutura de Dados e API do Módulo \texttt{build\_model}}
\author{Equipe de Desenvolvimento}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage

\chapter{Introdução}
Este relatório complementa a auditoria do avaliador, focando agora no módulo \texttt{build\_model.c/h}. Enquanto o avaliador sofre de problemas de responsabilidade, o Modelo de Build apresenta deficiências em \textbf{eficiência de memória}, \textbf{segurança de dados (lifetime)} e \textbf{design de API}.

A refatoração deste módulo deve ocorrer após a estabilização do \texttt{transpiler\_evaluator}, visando transformar o modelo em uma base sólida, performática e segura para grandes projetos.

\chapter{Eficiência de Memória e Performance}

\section{Desperdício em Matrizes Esparsas}
A estrutura \texttt{Build\_Target} aloca arrays estáticos para todas as configurações de build possíveis, independentemente de serem utilizadas.

\begin{lstlisting}[caption={Alocação redundante por Target}]
typedef struct {
    // ...
    struct {
        String_List compile_definitions;
        // ... mais 4 listas
    } properties[CONFIG_ALL + 1]; // 5 configs fixas
} Build_Target;
\end{lstlisting}

\textbf{Problema:} Se um projeto tem 1000 targets e usa apenas a configuração "Debug", o sistema aloca memória para 5000 estruturas de propriedades vazias. Isso pressiona a Arena desnecessariamente.

\textbf{Recomendação:} Utilizar uma lista encadeada ou array dinâmico de propriedades, onde cada nó armazena qual configuração ele representa.

\section{Algoritmos de Busca Linear}
A recuperação de targets é feita exclusivamente por comparação de strings em loop linear ($O(N)$).

\begin{lstlisting}[caption={Busca Linear em build\_model.c}]
Build_Target* build_model_find_target(...) {
    for (size_t i = 0; i < model->target_count; i++) {
        if (nob_sv_eq(model->targets[i].name, name)) ...
    }
}
\end{lstlisting}

\textbf{Problema:} Em operações como validação de dependências e ordenação topológica, a complexidade total se torna quadrática ($O(N^2)$) ou pior. Em projetos massivos, isso causará lentidão perceptível no tempo de configuração.

\textbf{Recomendação:} Implementar uma Tabela Hash (\texttt{name} $\to$ \texttt{target\_index}) interna no \texttt{Build\_Model}.

\chapter{Segurança e Ciclo de Vida (Lifetime)}

\section{Uso Perigoso de \texttt{String\_View}}
O modelo armazena \texttt{String\_View} extensivamente sem garantia de posse (ownership) dos dados.

\textbf{Problema:} O tipo \texttt{String\_View} é apenas um ponteiro e um tamanho. Se a string original vier de um buffer de leitura temporário do parser (que é sobrescrito ou liberado), o modelo ficará apontando para memória corrompida.

\textbf{Risco:} Comportamento indefinido (crashes aleatórios) quando o projeto cresce e buffers são reutilizados.

\textbf{Recomendação:} As funções "setter" do modelo devem obrigatoriamente duplicar strings para a Arena do modelo (\texttt{arena\_strdup}), garantindo que o modelo seja dono de seus dados.

\section{Resolução de Dependências Fraca}
As dependências são armazenadas apenas como strings (nomes), não como referências diretas.

\begin{lstlisting}
String_List dependencies; // Lista de nomes "libA", "libB"
\end{lstlisting}

\textbf{Problema:} Para acessar propriedades de uma dependência (ex: saber se é estática ou compartilhada), é necessário realizar uma nova busca pelo nome.

\textbf{Recomendação:} Adicionar uma etapa de "Pós-Processamento" ou "Linkagem do Modelo" que resolve nomes em ponteiros \texttt{Build\_Target*} diretos.

\chapter{Design de API e Abstração}

\section{Assinaturas Verborrágicas}
Quase todas as funções da API exigem a passagem explícita da Arena.

\begin{lstlisting}
void build_target_add_source(Build_Target *t, Arena *a, ...);
\end{lstlisting}

\textbf{Problema:} O objeto \texttt{Build\_Target} já pertence a um \texttt{Build\_Model}, que por sua vez possui (ou deveria possuir referência para) a Arena principal. Passar a arena manualmente é redundante e propenso a erros (passar a arena errada).

\textbf{Recomendação:} Armazenar o contexto da Arena no \texttt{Build\_Model} e simplificar a API para receber apenas os objetos de domínio.

\section{Vazamento de Abstração (Leaky Abstractions)}
O arquivo de cabeçalho \texttt{build\_model.h} expõe detalhes de implementação de contêineres genéricos.

\textbf{Problema:} As definições de \texttt{String\_List} e \texttt{Property\_List} estão no header principal do domínio. Isso polui o namespace e acopla o modelo a uma implementação específica de lista.

\textbf{Recomendação:} Mover estruturas de dados genéricas para \texttt{containers.h} ou \texttt{utils.h}.

\chapter{Plano de Ação Sugerido}

A refatoração do \texttt{build\_model} deve ocorrer na seguinte ordem de prioridade:

\begin{enumerate}
    \item \textbf{Segurança de Dados (Crítico):} 
    Alterar setters para realizar \texttt{arena\_strdup} internamente. Isso previne bugs de memória durante a refatoração do transpiler.
    
    \item \textbf{Limpeza de API (Usabilidade):}
    Simplificar assinaturas removendo \texttt{Arena*} desnecessários e encapsulando a lógica de alocação dentro do modelo.
    
    \item \textbf{Otimização (Performance/Memória):}
    Implementar Hash Maps para busca de targets e otimizar o armazenamento de propriedades (apenas quando o projeto escalar).
\end{enumerate}

\section{Conclusão}
Embora funcional, o \texttt{build\_model} atual opera como uma estrutura de dados "burra" (POD - Plain Old Data) com riscos de segurança de memória. Transformá-lo em um gerenciador de estado inteligente, que protege seus dados e otimiza o acesso, é fundamental para a robustez do transpiler a longo prazo.

\end{document}