\documentclass[a4paper,12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{fancyhdr}

% Configuração de margens
\geometry{left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}

% Configuração de cores para código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{codeblue}{rgb}{0.1,0.1,0.8}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{codeblue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=single,
    language=C
}

\lstset{style=mystyle}

% Cabeçalho e Rodapé
\pagestyle{fancy}
\fancyhf{}
\rhead{\today}
\lhead{Especificação Técnica: Motor Lógico}
\rfoot{Página \thepage}

\title{\textbf{Especificação Técnica: Motor de Lógica e Avaliação Condicional}\\ \large Arquitetura para Transpiler CMake em C}
\author{Equipe de Desenvolvimento}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage

\chapter{Introdução e Justificativa}

O atual modelo de transpilação enfrenta desafios ao lidar com a natureza dinâmica do CMake, especificamente no que tange a \textit{Generator Expressions} (ex: \texttt{\$<CONFIG:Debug>}) e lógica condicional complexa que não pode ser resolvida inteiramente durante o parsing.

Este documento propõe a implementação do \textbf{Padrão de Especificação (Specification Pattern)}, adaptado para C através de uma Árvore de Sintaxe Abstrata (AST) Lógica. Esta abordagem visa:

\begin{enumerate}
    \item \textbf{Desacoplamento:} Separar a definição da regra lógica da sua avaliação.
    \item \textbf{Otimização de Memória:} Eliminar a necessidade de arrays esparsos e redundantes para cada configuração de build (Debug, Release, etc.).
    \item \textbf{Avaliação Tardia (Deferred Evaluation):} Permitir que expressões lógicas sejam armazenadas como dados e avaliadas apenas no momento da geração do código final (\texttt{nob.c}).
\end{enumerate}

\chapter{Estrutura de Dados Lógica}

A base da implementação é uma árvore binária onde os nós representam operações booleanas ou predicados de consulta ao estado do build.

\section{Tipos de Operações (Enums)}
Definimos um enumerador que abrange operadores lógicos clássicos e predicados específicos do domínio CMake.

\begin{lstlisting}[caption={Definição de Tipos Lógicos em logic\_model.h}]
typedef enum {
    // --- Operadores de Composição ---
    LOGIC_OP_AND,       // E Lógico (&&)
    LOGIC_OP_OR,        // OU Lógico (||)
    LOGIC_OP_NOT,       // NÃO Lógico (!)
    
    // --- Comparadores ---
    LOGIC_OP_STREQUAL,  // Comparação de Strings
    
    // --- Predicados (Folhas da Árvore) ---
    LOGIC_OP_BOOL,         // Verifica se variável é "TRUE"/"ON"/"1"
    LOGIC_OP_DEFINED,      // Verifica existência de variável
    LOGIC_OP_EXISTS,       // Verifica existência de arquivo
    LOGIC_OP_CONFIG_MATCH, // Equivalente a $<CONFIG:...>
    LOGIC_OP_PLATFORM_ID,  // Equivalente a $<PLATFORM_ID:...>
    
    // --- Constantes ---
    LOGIC_OP_LITERAL_TRUE,
    LOGIC_OP_LITERAL_FALSE
} Logic_Op_Type;
\end{lstlisting}

\section{O Nó Lógico (Logic Node)}
A estrutura unificada para composição da árvore, alocada estritamente via Arena para garantir gerenciamento de memória eficiente.

\begin{lstlisting}[caption={Estrutura do Nó Lógico}]
typedef struct Logic_Node Logic_Node;

struct Logic_Node {
    Logic_Op_Type type;
    
    // Ramos para operações binárias (AND, OR, STREQUAL)
    // Para operações unárias (NOT), usa-se apenas 'left'
    Logic_Node *left;
    Logic_Node *right;
    
    // Payload para predicados (Folhas)
    // Ex: Se type == LOGIC_OP_CONFIG_MATCH, value contém "Debug"
    // Ex: Se type == LOGIC_OP_BOOL, value contém o nome da variável
    String_View value; 
};
\end{lstlisting}

\chapter{API de Construção (Factory)}

Para manter a integridade da árvore e facilitar o uso pelo parser, utilizamos funções construtoras ("Factories") que encapsulam a alocação na Arena.

\section{Construtores de Predicados}

\begin{lstlisting}[caption={Funções de Criação Básica}]
// Cria um nó representando 'true' incondicional
Logic_Node* logic_true(Arena *arena) {
    Logic_Node *n = arena_alloc(arena, sizeof(Logic_Node));
    n->type = LOGIC_OP_LITERAL_TRUE;
    return n;
}

// Cria uma verificação de variável booleana
Logic_Node* logic_var(Arena *arena, String_View var_name) {
    Logic_Node *n = arena_alloc(arena, sizeof(Logic_Node));
    n->type = LOGIC_OP_BOOL;
    n->value = var_name; // Deve ser duplicada se necessário
    return n;
}

// Cria uma verificação de configuração de build
Logic_Node* logic_config_match(Arena *arena, String_View config) {
    Logic_Node *n = arena_alloc(arena, sizeof(Logic_Node));
    n->type = LOGIC_OP_CONFIG_MATCH;
    n->value = config;
    return n;
}
\end{lstlisting}

\section{Composição Lógica}

\begin{lstlisting}[caption={Funções de Agregação}]
Logic_Node* logic_and(Arena *arena, Logic_Node *a, Logic_Node *b) {
    if (!a) return b; // Simplificação: NULL atua como neutro ou erro
    if (!b) return a;
    Logic_Node *n = arena_alloc(arena, sizeof(Logic_Node));
    n->type = LOGIC_OP_AND;
    n->left = a;
    n->right = b;
    return n;
}

Logic_Node* logic_not(Arena *arena, Logic_Node *node) {
    Logic_Node *n = arena_alloc(arena, sizeof(Logic_Node));
    n->type = LOGIC_OP_NOT;
    n->left = node;
    return n;
}
\end{lstlisting}

\chapter{Integração com o Build Model}

A adoção do motor lógico altera fundamentalmente a estrutura \texttt{Build\_Target}. Substituímos matrizes fixas por listas lineares de propriedades condicionais.

\section{Propriedade Condicional}
Esta estrutura associa um valor (ex: uma flag de compilação) a uma condição lógica arbitrária.

\begin{lstlisting}[caption={Nova Estrutura de Propriedade}]
typedef struct {
    String_View value;       // O dado (-DDEBUG, -O3, lib.a)
    Logic_Node *condition;   // A regra de aplicação (pode ser NULL para incondicional)
} Conditional_Property;

typedef struct {
    Conditional_Property *items;
    size_t count;
    size_t capacity;
} Conditional_Property_List;
\end{lstlisting}

\section{Refatoração do Build Target}
\begin{lstlisting}[caption={Build Target Otimizado}]
typedef struct {
    String_View name;
    Target_Type type;
    
    // Listas unificadas substituem 'properties[CONFIG_ALL + 1]'
    Conditional_Property_List compile_definitions;
    Conditional_Property_List compile_options;
    Conditional_Property_List link_libraries;
    Conditional_Property_List include_directories;
    
    // ... demais campos
} Build_Target;
\end{lstlisting}

\chapter{Motor de Avaliação}

O avaliador percorre a árvore recursivamente para determinar se uma propriedade deve ser aplicada dado o contexto atual (configuração, plataforma, variáveis).

\begin{lstlisting}[caption={Implementação do Avaliador}]
bool logic_evaluate(const Logic_Node *node, 
                    const Build_Model *model, 
                    Build_Config current_config) {
    if (!node) return true; // Sem condição implica verdadeiro

    switch (node->type) {
        case LOGIC_OP_LITERAL_TRUE: return true;
        case LOGIC_OP_LITERAL_FALSE: return false;

        case LOGIC_OP_AND:
            return logic_evaluate(node->left, model, current_config) &&
                   logic_evaluate(node->right, model, current_config);

        case LOGIC_OP_OR:
            return logic_evaluate(node->left, model, current_config) ||
                   logic_evaluate(node->right, model, current_config);

        case LOGIC_OP_NOT:
            return !logic_evaluate(node->left, model, current_config);

        case LOGIC_OP_BOOL: {
            // Resolve variavel no modelo
            String_View val = build_model_resolve_var(model, node->value);
            return !cmake_string_is_false(val);
        }

        case LOGIC_OP_CONFIG_MATCH: {
            // Compara com a configuração sendo gerada no momento
            String_View cfg_str = build_config_to_string(current_config);
            return nob_sv_eq_ignore_case(cfg_str, node->value);
        }
        
        // ... implementação dos demais casos
    }
    return false;
}
\end{lstlisting}

\chapter{Estratégia de Implementação}

A migração deve seguir as etapas abaixo para garantir estabilidade:

\begin{enumerate}
    \item \textbf{Infraestrutura:} Criação dos arquivos \texttt{logic\_model.h} e \texttt{logic\_model.c} com as structs e funções de fábrica.
    \item \textbf{Adaptação do Parser:} Modificar o \texttt{transpiler\_evaluator} para converter \textit{Generator Expressions} em árvores \texttt{Logic\_Node} ao invés de tentar resolvê-las imediatamente como strings.
    \item \textbf{Migração de Dados:} Alterar o \texttt{Build\_Target} para usar \texttt{Conditional\_Property\_List}. Atualizar setters para aceitar condições opcionais.
    \item \textbf{Geração de Código:} Atualizar o backend gerador de C (\texttt{nob.c}) para iterar sobre as listas condicionais e gerar blocos \texttt{if (condição) \{ ... \}} quando necessário, ou filtrar estaticamente se a condição for constante.
\end{enumerate}

\end{document}